VERSION CONTROL WITH GIT
Company : CODTECH IT SOLUTIONS
Name : Vaibhav Gawali
Intern ID: CT04DH1004
Domain : DEVOPS
Duration : 4 WEEKS
Mentor : NEELA SANTOSH

The task of implementing version control using Git was designed to provide hands-on experience with one of the most essential tools in modern software development. Version control systems like Git allow teams and individuals to track changes in code, collaborate seamlessly, and resolve conflicts efficiently when multiple developers work on the same project. The primary objective of this task was to manually set up a Git repository, create and manage branches, simulate a merge conflict, resolve it, and document the entire process in a structured manner. This practical exercise not only demonstrated the core functionalities of Git but also reflected real-world scenarios that software teams encounter on a daily basis.
The process began by manually initializing a new Git repository in a local directory named git-version-control-demo. This was accomplished using the git init command, which created a .git directory and configured the current folder for version control. An initial file named file.txt was created with a simple welcome message, and this file was then staged and committed to the repository using git add and git commit. This commit served as the initial state of the project and marked the beginning of the version-controlled history.
To simulate parallel development, two separate branches were created from the main line of development. The first branch, named feature-one, was created and checked out using git checkout -b feature-one. A new line was appended to the file.txt file indicating changes from this branch, followed by staging and committing the changes. Similarly, the second branch, feature-two, was created from the main branch. In this branch, a different line was added to the same file and at the same location, with the intention of triggering a merge conflict during the integration phase. These changes were also staged and committed independently.
The next step involved attempting to merge the feature-one branch into the feature-two branch. As expected, Git encountered a merge conflict because both branches had made changes to the same file in the same area. Git responded with conflict markers in the file, displaying the conflicting content from both branches between special markers (<<<<<<<, =======, and >>>>>>>). This situation mirrors real-world cases where multiple developers modify the same portion of code, and Git is unable to automatically determine which changes should take precedence.
To resolve the conflict, the file was opened and manually edited to include both lines in a meaningful order, thereby preserving the contributions from both branches. After manually cleaning the conflict markers and finalizing the content, the file was staged again and a new commit was created to finalize the merge. This demonstrated a successful resolution of a merge conflict.
In order to provide transparency and clarity, a new file named MERGE_CONFLICT_RESOLUTION.md was created to document the entire process. This file included information about the conflicting file, the branches involved, a description of the conflict, how it was resolved, and the Git commands used during the resolution. This form of documentation is critical in professional environments to ensure traceability and team communication.
Finally, the feature-two branch, which now contained the resolved changes from both features, was merged back into the main branch, completing the full version control workflow. The complete Git history was verified using the git log --oneline --graph --all command to visualize the branch structure and the merge process. This task not only reinforced fundamental Git concepts like branching, merging, and conflict resolution but also emphasized the importance of proper commit messages and documentation in collaborative development environments.

