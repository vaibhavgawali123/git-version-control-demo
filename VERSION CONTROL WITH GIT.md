# VERSION CONTROL WITH GIT

**Company**: CODTECH IT SOLUTIONS  
**Name**: Vaibhav Gawali  
**Intern ID**: CT04DH1004  
**Domain**: DEVOPS  
**Duration**: 4 WEEKS  
**Mentor**: NEELA SANTOSH  

As part of my coursework on version control systems, I was given a practical task to manually set up a Git repository, create branches, introduce and resolve a merge conflict, and document the steps involved. The main objective was to understand how Git works in real-world development environments and to experience first-hand how developers use Git to collaborate, track code changes, and manage conflicts. I completed this task on my local machine using Git Bash, and the entire process gave me a deeper understanding of Git operations beyond just theory.
I began by creating a new folder on my desktop named git-version-control-demo. Inside this folder, I initialized a Git repository by running the command git init. This created a hidden .git directory which allowed Git to start tracking changes. Then, I created a simple file called file.txt using the echo command and wrote “Welcome to Git Demo” inside it. I added this file to the staging area using git add and made my first commit with the message “Initial commit: added file.txt with welcome message”. This served as the base version of my project.
After setting up the initial commit, I moved on to simulate collaborative development by creating two separate branches. I first created a branch called feature-one and switched to it using git checkout -b feature-one. In this branch, I added a new line to file.txt that said “This line is from feature-one branch.” and committed the changes. Then I switched back to the main branch and created another branch called feature-two. In the feature-two branch, I added a different line to the same file saying “This line is from feature-two branch.” and committed those changes as well.
With both branches having changes to the same file, I proceeded to merge feature-one into feature-two. As expected, Git reported a merge conflict because both branches had modified the same section of the file. When I opened file.txt, I saw the conflict markers inserted by Git to show the changes from both branches. This was the first time I encountered a real conflict while working with Git, and it helped me understand what happens internally when Git can’t automatically merge changes.
To resolve the conflict, I manually edited the file and kept both lines, one after the other, to preserve changes from both branches. I removed the conflict markers and then staged the file using git add, followed by committing it with the message “Resolved merge conflict between feature-one and feature-two”. This resolved the conflict successfully. After that, I switched back to the main branch and merged the updated feature-two branch into it, completing the integration process.
To document this experience, I created a new markdown file called MERGE_CONFLICT_RESOLUTION.md where I explained which branches were involved, what caused the conflict, how I resolved it, and listed the Git commands I used. I committed this documentation file to the repository as well. Finally, I checked the commit history using git log --oneline --graph --all, which showed a clear history of commits, branches, and merges.
Overall, this task helped me understand the importance of version control in software development. It gave me practical exposure to branching strategies, merge conflict resolution, and proper commit documentation, all of which are essential skills for developers working in teams.eatures, was merged back into the main branch, completing the full version control workflow. The complete Git history was verified using the git log --oneline --graph --all command to visualize the branch structure and the merge process. This task not only reinforced fundamental Git concepts like branching, merging, and conflict resolution but also emphasized the importance of proper commit messages and documentation in collaborative development environments.

